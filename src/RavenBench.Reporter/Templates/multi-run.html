<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RavenBench Multi-Run Comparison</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
  <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; margin: 24px; color: #0f172a; background-color: #f8fafc; }
    h1, h2 { color: #0f172a; margin-bottom: 12px; }
    h1 { font-size: 28px; }
    h2 { font-size: 20px; margin-top: 32px; }
    section { background: #ffffff; border-radius: 12px; padding: 20px; box-shadow: 0 1px 3px rgba(15, 23, 42, 0.1); margin-bottom: 24px; }
    .meta-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-top: 12px; }
    .meta-item { background: #f1f5f9; padding: 12px; border-radius: 8px; font-size: 14px; }
    .meta-item strong { display: block; margin-bottom: 4px; font-size: 12px; text-transform: uppercase; color: #475569; }
    .notes { margin-top: 16px; padding: 12px; background: #e0f2fe; border-left: 4px solid #0ea5e9; border-radius: 8px; }
    
    /* Run summary cards */
    .run-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px; margin: 16px 0; }
    .run-card { background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 12px; padding: 16px; cursor: pointer; transition: all 0.2s ease; }
    .run-card:hover { background: #e0f2fe; border-color: #0ea5e9; transform: translateY(-2px); box-shadow: 0 4px 6px rgba(14, 165, 233, 0.1); }
    .run-card.baseline { border-color: #2563eb; background: #eff6ff; }
    .run-card-title { font-size: 16px; font-weight: 600; margin-bottom: 12px; color: #1e293b; }
    .run-card-metrics { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
    .metric { font-size: 13px; }
    .metric-label { color: #64748b; display: block; }
    .metric-value { font-weight: 600; color: #0f172a; }
    .metric-delta { font-size: 11px; margin-left: 4px; }
    .metric-delta.positive { color: #16a34a; }
    .metric-delta.negative { color: #dc2626; }
    
    /* Charts */
    .chart-row { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 16px; margin: 16px 0; }
    .chart-box { min-width: 0; height: 400px; position: relative; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px; }
    .chart-box-full { width: 100%; max-width: 960px; height: 400px; margin: 16px auto; position: relative; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px; }
    canvas.chart-canvas { display: block; width: 100% !important; height: 100% !important; max-height: 360px; }
    
    /* Contrast cards */
    .contrast-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; margin: 16px 0; }
    .contrast-card { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; cursor: pointer; transition: all 0.2s ease; }
    .contrast-card:hover { background: #e0f2fe; border-color: #0ea5e9; transform: translateY(-2px); box-shadow: 0 4px 6px rgba(14, 165, 233, 0.1); }
    .contrast-card.selected { background: #dbeafe; border-color: #2563eb; border-width: 2px; }
    .contrast-title { font-size: 13px; font-weight: 600; margin-bottom: 8px; color: #475569; }
    .contrast-value { font-size: 18px; font-weight: 700; color: #0f172a; }
    .contrast-delta { font-size: 14px; margin-top: 4px; }
    
    /* Takeaways */
    .takeaways { background: #f0fdf4; border-left: 4px solid #16a34a; padding: 16px; border-radius: 8px; margin: 16px 0; }
    .takeaways ul { margin: 8px 0; padding-left: 20px; }
    .takeaways li { margin: 6px 0; color: #0f172a; }
    
    footer { text-align: center; font-size: 11px; color: #475569; margin-top: 32px; }
    
    @page {
      size: A4 landscape;
      margin: 12mm;
    }
    
    @media print {
      * {
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }
      body {
        margin: 0;
        background: white;
      }
      section {
        page-break-inside: avoid;
      }
    }
  </style>
</head>
<body>
  <header style="background: #ffffff; border-radius: 8px; padding: 16px; margin-bottom: 24px; box-shadow: 0 1px 3px rgba(15, 23, 42, 0.1);">
    <h1 id="report-title">RavenBench Multi-Run Comparison</h1>
    <div id="meta-summary" style="font-size: 13px; color: #64748b; margin-top: 8px;"></div>
    <p class="notes" id="report-notes" style="display:none;"></p>
  </header>

  <section>
    <h2>Run Summary</h2>
    <div class="run-cards" id="run-cards"></div>
  </section>

  <section>
    <h2>Key Takeaways</h2>
    <div class="takeaways">
      <ul id="key-takeaways"></ul>
    </div>
  </section>

  <section>
    <h2>Throughput &amp; Latency Comparison</h2>
    <div class="chart-row">
      <div class="chart-box"><canvas id="throughputComparisonChart" class="chart-canvas"></canvas></div>
      <div class="chart-box"><canvas id="p99ComparisonChart" class="chart-canvas"></canvas></div>
    </div>
  </section>

  <section id="latency-spotlight-section">
    <h2>Latency Spotlight</h2>
    <div id="latency-summary-table" style="margin: 16px 0; padding: 16px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;"></div>

    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
      <h3 style="font-size: 16px; margin: 0;" id="comparison-title">All at baseline's optimal C=<span id="baseline-c-label"></span></h3>
      <button id="toggle-comparison" style="padding: 6px 12px; font-size: 12px; cursor: pointer; border: 1px solid #2563eb; background: #ffffff; color: #2563eb; border-radius: 4px; font-weight: 500;">
        Switch to Own Optimal C
      </button>
    </div>
    <div style="padding: 12px; background: #eff6ff; border-radius: 8px; border: 2px solid #2563eb;">
      <div style="display: flex; gap: 16px;" id="comparison-row"></div>
    </div>

    <div class="chart-box-full" style="margin-top: 20px;">
      <div style="text-align: right; margin-bottom: 8px; display: flex; gap: 8px; justify-content: flex-end;">
        <button id="toggle-tail-zoom" style="padding: 6px 12px; font-size: 12px; cursor: pointer; border: 1px solid #2563eb; background: #ffffff; color: #2563eb; border-radius: 4px; font-weight: 500;">
          Zoom to Tail (90-100)
        </button>
        <button id="toggle-y-axis" style="padding: 6px 12px; font-size: 12px; cursor: pointer; border: 1px solid #2563eb; background: #ffffff; color: #2563eb; border-radius: 4px; font-weight: 500;">
          Switch to Linear Y-Axis
        </button>
      </div>
      <canvas id="percentileComparisonChart" class="chart-canvas"></canvas>
    </div>
  </section>

  <section id="resource-comparison-section">
    <h2>Resource Cost Comparison</h2>
    <div class="chart-row">
      <div class="chart-box"><canvas id="cpuComparisonChart" class="chart-canvas"></canvas></div>
      <div class="chart-box"><canvas id="memoryComparisonChart" class="chart-canvas"></canvas></div>
    </div>
  </section>

  <footer>
    RavenBench Reporter — Multi-Run Comparison
  </footer>

  <script id="report-context" type="application/json">__REPORT_CONTEXT__</script>
  <script id="comparison-model" type="application/json">__COMPARISON_MODEL__</script>
  <script>
    (function () {
      try {
        if (window.Chart) {
          const annotationPlugin = window.ChartAnnotation || window['chartjs-plugin-annotation'];
          if (annotationPlugin) {
            Chart.register(annotationPlugin);
          }
        }

        const contextElement = document.getElementById('report-context');
        const modelElement = document.getElementById('comparison-model');

        if (!contextElement || !modelElement) {
          console.error('Report template is missing expected data payloads.');
          window.__reportRendered = true;
          return;
        }

        const context = JSON.parse(contextElement.textContent || '{}');
        const model = JSON.parse(modelElement.textContent || '{}');

        window.__reportRendered = false;

        // Set title and notes
        const title = context.title || 'RavenBench Multi-Run Comparison';
        document.getElementById('report-title').textContent = title;

        const notes = (context.notes || '').trim();
        const notesElement = document.getElementById('report-notes');
        if (notes.length > 0) {
          notesElement.textContent = notes;
          notesElement.style.display = 'block';
        }

        // Meta summary
        const metaSummary = document.getElementById('meta-summary');
        const baseline = model.baseline;
        if (baseline && baseline.summary) {
          const profileNames = {
            0: 'Unspecified', 1: 'Mixed', 2: 'Writes', 3: 'Reads',
            4: 'QueryById', 5: 'BulkWrites', 6: 'StackOverflowReads',
            7: 'StackOverflowQueries', 8: 'QueryUsersByName'
          };
          const profile = profileNames[baseline.summary.options?.profile] || 'Scenario';
          metaSummary.textContent = `Profile: ${profile} • Transport: ${baseline.summary.options?.transport || 'n/a'} • HTTP: ${baseline.summary.effectiveHttpVersion || 'n/a'} • Generated: ${context.generatedAt || 'n/a'}`;
        }

        // Color palette for runs (needed by multiple functions)
        // Expanded palette to support 6+ versions with distinguishable colors
        const runColors = ['#2563eb', '#dc2626', '#16a34a', '#f59e0b', '#8b5cf6', '#ec4899'];

        // All runs (baseline + contenders) - needed by multiple functions
        let allRuns = [model.baseline].concat(model.contenders || []);
        let currentBaselineIndex = 0;

        // Aligned steps - needed by multiple functions
        const alignedSteps = model.alignedSteps || [];
        const concurrencies = alignedSteps.map(s => s.concurrency);

        // Chart references
        let throughputChart = null;
        let p99Chart = null;
        let cpuChart = null;
        let memoryChart = null;

        // Latency contrast references
        const latencyContrastsContainer = document.getElementById('latency-contrasts');
        let contrastCards = [];

        // Helper function to calculate quality score at a specific concurrency
        function calculateQualityScoreAtConcurrency(run, targetConcurrency) {
          // Find the step at the target concurrency
          const runIndex = allRuns.indexOf(run);
          const alignedStep = alignedSteps.find(s => s.concurrency === targetConcurrency);
          if (!alignedStep) return null;

          const metrics = alignedStep.runMetrics[runIndex];
          if (!metrics) return null;

          // Quality score formula: throughput / (1 + p99)
          const qualityScore = metrics.throughput / (1 + metrics.p99);
          return qualityScore;
        }

        // Helper function to render card metrics - always shows each run's own best
        function renderCardMetrics(card, run, runIndex, baselineRun) {
          const isBaseline = runIndex === currentBaselineIndex;

          // Always show each run's own best step (knee)
          const bestStep = run.bestStep;
          const throughput = bestStep ? bestStep.throughput.toFixed(0) : 'N/A';
          const p99 = bestStep && bestStep.raw ? bestStep.raw.p99.toFixed(2) : 'N/A';
          const p999 = bestStep && bestStep.raw ? bestStep.raw.p999.toFixed(2) : 'N/A';
          const errorRate = bestStep ? (bestStep.errorRate * 100).toFixed(3) : 'N/A';
          const concurrency = bestStep ? bestStep.concurrency : 'N/A';
          const qualityScore = run.bestQualityScore ? run.bestQualityScore.toFixed(1) : 'N/A';

          const titleSuffix = isBaseline ? '(Baseline)' : '';

          card.innerHTML = `
            <div class="run-card-title">${run.label} ${titleSuffix}</div>
            <div class="run-card-metrics">
              <div class="metric">
                <span class="metric-label">Best Throughput</span>
                <span class="metric-value">${throughput} ops/s</span>
              </div>
              <div class="metric">
                <span class="metric-label">Knee Concurrency</span>
                <span class="metric-value">${concurrency}</span>
              </div>
              <div class="metric">
                <span class="metric-label">P99 Latency</span>
                <span class="metric-value">${p99} ms</span>
              </div>
              <div class="metric">
                <span class="metric-label">P99.9 Latency</span>
                <span class="metric-value">${p999} ms</span>
              </div>
              <div class="metric">
                <span class="metric-label">Error Rate</span>
                <span class="metric-value">${errorRate}%</span>
              </div>
              <div class="metric">
                <span class="metric-label">Quality Score</span>
                <span class="metric-value">${qualityScore}</span>
              </div>
            </div>
          `;
        }

        // Render run summary cards
        const runCardsContainer = document.getElementById('run-cards');
        const runCards = [];

        allRuns.forEach((run, index) => {
          const card = document.createElement('div');
          card.className = index === 0 ? 'run-card baseline' : 'run-card';

          // Initial render with first run as baseline
          renderCardMetrics(card, run, index, allRuns[0]);

          card.addEventListener('click', () => {
            if (currentBaselineIndex === index) return; // Already baseline

            // Swap baseline
            currentBaselineIndex = index;

            // Update all cards with new baseline
            const newBaseline = allRuns[currentBaselineIndex];
            runCards.forEach((c, i) => {
              if (i === currentBaselineIndex) {
                c.classList.add('baseline');
              } else {
                c.classList.remove('baseline');
              }
              renderCardMetrics(c, allRuns[i], i, newBaseline);
            });

            // Update all charts
            updateAllCharts();
          });

          runCards.push(card);
          runCardsContainer.appendChild(card);
        });

        // Render key takeaways
        const takeawaysList = document.getElementById('key-takeaways');
        (model.keyTakeaways || []).forEach(takeaway => {
          const li = document.createElement('li');
          li.textContent = takeaway;
          takeawaysList.appendChild(li);
        });

        // Function to get reordered runs based on current baseline
        function getReorderedRuns() {
          const reordered = [...allRuns];
          if (currentBaselineIndex !== 0) {
            // Move currentBaselineIndex to position 0
            const [baseline] = reordered.splice(currentBaselineIndex, 1);
            reordered.unshift(baseline);
          }
          return reordered;
        }

        // Function to regenerate latency contrast cards based on current baseline
        function updateLatencyContrasts() {
          const orderedRuns = getReorderedRuns();
          const baseline = orderedRuns[0];
          const baselineKneeConcurrency = baseline.bestStep?.concurrency;

          // Update baseline C label
          const baselineCLabel = document.getElementById('baseline-c-label');
          if (baselineCLabel) {
            baselineCLabel.textContent = baselineKneeConcurrency || '?';
          }

          // Clear existing cards
          const comparisonRow = document.getElementById('comparison-row');
          if (comparisonRow) comparisonRow.innerHTML = '';
          contrastCards.length = 0;

          if (!baselineKneeConcurrency) return;

          // Render the cards based on current mode
          renderComparisonCards();

          // Update percentile chart
          updatePercentileChart();
        }

        // Function to render comparison cards based on current mode
        function renderComparisonCards() {
          const orderedRuns = getReorderedRuns();
          const baseline = orderedRuns[0];
          const baselineKneeConcurrency = baseline.bestStep?.concurrency;
          const comparisonRow = document.getElementById('comparison-row');
          const comparisonTitle = document.getElementById('comparison-title');
          const toggleButton = document.getElementById('toggle-comparison');

          if (!comparisonRow) return;
          comparisonRow.innerHTML = '';

          if (currentChartMode === 'same-c') {
            // All runs at baseline's concurrency
            if (comparisonTitle) {
              comparisonTitle.innerHTML = `All at baseline's optimal C=<span id="baseline-c-label">${baselineKneeConcurrency}</span>`;
            }
            if (toggleButton) {
              toggleButton.textContent = 'Switch to Own Optimal C';
            }

            orderedRuns.forEach((run, index) => {
              const alignedStep = alignedSteps.find(s => s.concurrency === baselineKneeConcurrency);
              if (!alignedStep) return;

              const metrics = alignedStep.runMetrics[allRuns.indexOf(run)];
              if (!metrics) return;

              const card = document.createElement('div');
              card.style.cssText = 'flex: 1; background: #ffffff; border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px;';

              const borderColor = runColors[index % runColors.length];
              card.style.borderColor = borderColor;

              const qualityScore = metrics.throughput / (1 + metrics.p99);

              card.innerHTML = `
                <div style="font-weight: 600; color: ${borderColor}; margin-bottom: 8px;">${run.label}</div>
                <div style="font-size: 13px; color: #64748b;">
                  <div><strong>${metrics.p99.toFixed(2)}</strong> ms P99</div>
                  <div><strong>${metrics.throughput.toFixed(0)}</strong> ops/s</div>
                  <div>QS: <strong>${qualityScore.toFixed(1)}</strong></div>
                </div>
              `;

              comparisonRow.appendChild(card);
            });
          } else {
            // Each run at its own optimal
            if (comparisonTitle) {
              comparisonTitle.textContent = 'Each at their own optimal C';
            }
            if (toggleButton) {
              toggleButton.textContent = `Switch to Baseline's C=${baselineKneeConcurrency}`;
            }

            orderedRuns.forEach((run, index) => {
              const bestStep = run.bestStep;
              if (!bestStep) return;

              const card = document.createElement('div');
              card.style.cssText = 'flex: 1; background: #ffffff; border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px;';

              const borderColor = runColors[index % runColors.length];
              card.style.borderColor = borderColor;

              const p99 = bestStep.raw?.p99 || bestStep.p99;
              const qualityScore = run.bestQualityScore;

              card.innerHTML = `
                <div style="font-weight: 600; color: ${borderColor}; margin-bottom: 8px;">${run.label} @ C=${bestStep.concurrency}</div>
                <div style="font-size: 13px; color: #64748b;">
                  <div><strong>${p99.toFixed(2)}</strong> ms P99</div>
                  <div><strong>${bestStep.throughput.toFixed(0)}</strong> ops/s</div>
                  <div>QS: <strong>${qualityScore.toFixed(1)}</strong></div>
                </div>
              `;

              comparisonRow.appendChild(card);
            });
          }
        }

        // Function to update all charts when baseline changes
        function updateAllCharts() {
          const orderedRuns = getReorderedRuns();

          // Get the mapping from old index to new index
          const indexMap = orderedRuns.map(r => allRuns.indexOf(r));

          // Update latency contrasts
          updateLatencyContrasts();

          // Update throughput chart
          if (throughputChart) {
            throughputChart.data.datasets = orderedRuns.map((run, newIndex) => {
              const oldIndex = allRuns.indexOf(run);
              return {
                label: run.label,
                data: alignedSteps.map(step => {
                  const metrics = step.runMetrics[oldIndex];
                  return metrics ? metrics.throughput : null;
                }),
                borderColor: runColors[newIndex % runColors.length],
                backgroundColor: runColors[newIndex % runColors.length],
                tension: 0.2,
                pointRadius: 4
              };
            });
            throughputChart.update();
          }

          // Update p99 chart
          if (p99Chart) {
            p99Chart.data.datasets = orderedRuns.map((run, newIndex) => {
              const oldIndex = allRuns.indexOf(run);
              return {
                label: run.label,
                data: alignedSteps.map(step => {
                  const metrics = step.runMetrics[oldIndex];
                  return metrics ? metrics.p99 : null;
                }),
                borderColor: runColors[newIndex % runColors.length],
                backgroundColor: runColors[newIndex % runColors.length],
                tension: 0.2,
                pointRadius: 4
              };
            });
            p99Chart.update();
          }

          // Update CPU chart
          if (cpuChart) {
            cpuChart.data.datasets = orderedRuns.map((run, newIndex) => {
              const oldIndex = allRuns.indexOf(run);
              return {
                label: run.label,
                data: alignedSteps.map(step => {
                  const metrics = step.runMetrics[oldIndex];
                  return metrics ? metrics.serverCpu : null;
                }),
                borderColor: runColors[newIndex % runColors.length],
                backgroundColor: runColors[newIndex % runColors.length],
                tension: 0.2,
                pointRadius: 4
              };
            });
            cpuChart.update();
          }

          // Update memory chart
          if (memoryChart) {
            memoryChart.data.datasets = orderedRuns.map((run, newIndex) => {
              const oldIndex = allRuns.indexOf(run);
              return {
                label: run.label,
                data: alignedSteps.map(step => {
                  const metrics = step.runMetrics[oldIndex];
                  return metrics ? metrics.serverMemoryMB : null;
                }),
                borderColor: runColors[newIndex % runColors.length],
                backgroundColor: runColors[newIndex % runColors.length],
                tension: 0.2,
                pointRadius: 4
              };
            });
            memoryChart.update();
          }
        }

        // Throughput comparison chart
        const throughputDatasets = allRuns.map((run, index) => ({
          label: run.label,
          data: alignedSteps.map(step => {
            const metrics = step.runMetrics[index];
            return metrics ? metrics.throughput : null;
          }),
          borderColor: runColors[index % runColors.length],
          backgroundColor: runColors[index % runColors.length],
          tension: 0.2,
          pointRadius: 4
        }));

        throughputChart = new Chart(document.getElementById('throughputComparisonChart'), {
          type: 'line',
          data: { labels: concurrencies, datasets: throughputDatasets },
          options: {
            animation: false,
            maintainAspectRatio: false,
            scales: {
              x: { title: { display: true, text: 'Concurrency' } },
              y: { title: { display: true, text: 'Throughput (ops/s)' }, beginAtZero: true }
            },
            plugins: { legend: { position: 'top' } }
          }
        });

        // P99 comparison chart
        const p99Datasets = allRuns.map((run, index) => ({
          label: run.label,
          data: alignedSteps.map(step => {
            const metrics = step.runMetrics[index];
            return metrics ? metrics.p99 : null;
          }),
          borderColor: runColors[index % runColors.length],
          backgroundColor: runColors[index % runColors.length],
          tension: 0.2,
          pointRadius: 4
        }));

        p99Chart = new Chart(document.getElementById('p99ComparisonChart'), {
          type: 'line',
          data: { labels: concurrencies, datasets: p99Datasets },
          options: {
            animation: false,
            maintainAspectRatio: false,
            scales: {
              x: { title: { display: true, text: 'Concurrency' } },
              y: { title: { display: true, text: 'P99 Latency (ms)' }, beginAtZero: true }
            },
            plugins: { legend: { position: 'top' } }
          }
        });

        // Percentile comparison chart - define before using
        let percentileChart = null;
        let isLogarithmic = true;
        let currentChartMode = 'same-c'; // 'same-c' or 'optimal-c'
        let isTailZoom = false; // false = 0-100, true = 90-100

        function updatePercentileChart() {
          // Get reordered runs to determine correct color indices
          const orderedRuns = getReorderedRuns();
          const baseline = orderedRuns[0];

          const percentileDatasets = [];

          if (currentChartMode === 'same-c') {
            // All runs at baseline's knee concurrency
            const baselineKneeConcurrency = baseline.bestStep?.concurrency;
            if (!baselineKneeConcurrency) return;

            orderedRuns.forEach((run, index) => {
              const histograms = run.summary.histogramArtifacts || [];
              const histogram = histograms.find(h => h.concurrency === baselineKneeConcurrency);

              if (histogram) {
                // Filter data based on zoom setting
                const data = histogram.percentiles
                  .map((p, i) => ({
                    x: p,
                    y: histogram.latencyInMilliseconds[i]
                  }))
                  .filter(point => !isTailZoom || point.x >= 90);

                percentileDatasets.push({
                  label: `${run.label} @ C=${baselineKneeConcurrency}`,
                  data: data,
                  borderColor: runColors[index % runColors.length],
                  backgroundColor: 'transparent',
                  borderWidth: 2,
                  pointRadius: 0,
                  tension: 0.3
                });
              }
            });
          } else {
            // Each run at its own optimal concurrency
            orderedRuns.forEach((run, index) => {
              const histograms = run.summary.histogramArtifacts || [];
              const optimalC = run.bestStep?.concurrency;
              if (!optimalC) return;

              const histogram = histograms.find(h => h.concurrency === optimalC);

              if (histogram) {
                // Filter data based on zoom setting
                const data = histogram.percentiles
                  .map((p, i) => ({
                    x: p,
                    y: histogram.latencyInMilliseconds[i]
                  }))
                  .filter(point => !isTailZoom || point.x >= 90);

                percentileDatasets.push({
                  label: `${run.label} @ C=${optimalC}`,
                  data: data,
                  borderColor: runColors[index % runColors.length],
                  backgroundColor: 'transparent',
                  borderWidth: 2,
                  pointRadius: 0,
                  tension: 0.3
                });
              }
            });
          }

          if (percentileDatasets.length > 0) {
            if (percentileChart) {
              percentileChart.data.datasets = percentileDatasets;
              percentileChart.options.scales.x.min = isTailZoom ? 90 : 0;
              percentileChart.options.scales.x.max = 100;
              percentileChart.update();
            } else {
              percentileChart = new Chart(document.getElementById('percentileComparisonChart'), {
                type: 'line',
                data: { datasets: percentileDatasets },
                options: {
                  parsing: false,
                  animation: false,
                  maintainAspectRatio: false,
                  scales: {
                    x: {
                      type: 'linear',
                      title: { display: true, text: 'Percentile' },
                      min: isTailZoom ? 90 : 0,
                      max: 100
                    },
                    y: {
                      type: isLogarithmic ? 'logarithmic' : 'linear',
                      title: { display: true, text: 'Latency (ms)' },
                      beginAtZero: !isLogarithmic
                    }
                  },
                  plugins: { legend: { position: 'top' } }
                }
              });
            }
          }
        }

        // Tail zoom toggle button
        const tailZoomButton = document.getElementById('toggle-tail-zoom');
        if (tailZoomButton) {
          tailZoomButton.addEventListener('click', () => {
            isTailZoom = !isTailZoom;
            tailZoomButton.textContent = isTailZoom ? 'Show Full Range (0-100)' : 'Zoom to Tail (90-100)';
            updatePercentileChart();
          });
        }

        // Y-axis toggle button
        const toggleButton = document.getElementById('toggle-y-axis');
        if (toggleButton) {
          toggleButton.addEventListener('click', () => {
            isLogarithmic = !isLogarithmic;
            toggleButton.textContent = isLogarithmic ? 'Switch to Linear Y-Axis' : 'Switch to Logarithmic Y-Axis';

            if (percentileChart) {
              percentileChart.options.scales.y.type = isLogarithmic ? 'logarithmic' : 'linear';
              percentileChart.options.scales.y.beginAtZero = !isLogarithmic;
              percentileChart.update();
            }
          });
        }

        // Toggle button handler
        const toggleComparisonButton = document.getElementById('toggle-comparison');
        if (toggleComparisonButton) {
          toggleComparisonButton.addEventListener('click', () => {
            currentChartMode = currentChartMode === 'same-c' ? 'optimal-c' : 'same-c';
            renderComparisonCards();
            updatePercentileChart();
          });
        }

        // Initialize latency contrasts
        updateLatencyContrasts();

        // CPU comparison (per concurrency level)
        const cpuDatasets = allRuns.map((run, index) => ({
          label: run.label,
          data: alignedSteps.map(step => {
            const metrics = step.runMetrics[index];
            return metrics ? metrics.serverCpu : null;
          }),
          borderColor: runColors[index % runColors.length],
          backgroundColor: runColors[index % runColors.length],
          tension: 0.2,
          pointRadius: 4
        }));

        cpuChart = new Chart(document.getElementById('cpuComparisonChart'), {
          type: 'line',
          data: {
            labels: concurrencies,
            datasets: cpuDatasets
          },
          options: {
            animation: false,
            maintainAspectRatio: false,
            scales: {
              x: { title: { display: true, text: 'Concurrency' } },
              y: { title: { display: true, text: 'CPU %' }, beginAtZero: true, suggestedMax: 100 }
            },
            plugins: { legend: { position: 'top' } }
          }
        });

        // Memory comparison (per concurrency level)
        const memoryDatasets = allRuns.map((run, index) => ({
          label: run.label,
          data: alignedSteps.map(step => {
            const metrics = step.runMetrics[index];
            return metrics ? metrics.serverMemoryMB : null;
          }),
          borderColor: runColors[index % runColors.length],
          backgroundColor: runColors[index % runColors.length],
          tension: 0.2,
          pointRadius: 4
        }));

        memoryChart = new Chart(document.getElementById('memoryComparisonChart'), {
          type: 'line',
          data: {
            labels: concurrencies,
            datasets: memoryDatasets
          },
          options: {
            animation: false,
            maintainAspectRatio: false,
            scales: {
              x: { title: { display: true, text: 'Concurrency' } },
              y: { title: { display: true, text: 'Memory (MB)' }, beginAtZero: true }
            },
            plugins: { legend: { position: 'top' } }
          }
        });

        window.__reportRendered = true;
      } catch (error) {
        console.error('Failed to render comparison report', error);
        window.__reportRendered = true;
      }
    })();
  </script>
</body>
</html>
